[package]
name = "claude-snatch"
version = "0.1.0"
edition = "2021"
rust-version = "1.75.0"
authors = ["claude-snatch contributors"]
description = "High-performance CLI/TUI tool for extracting and analyzing Claude Code conversation logs"
license = "MIT"
repository = "https://github.com/jkindrix/claude-snatch"
keywords = ["claude", "code", "jsonl", "extraction", "cli", "tui"]
categories = ["command-line-utilities", "development-tools"]
readme = "README.md"

[dependencies]
# CLI Framework
clap = { version = "4.5", features = ["derive", "env", "string", "wrap_help"] }
clap_complete = "4.5"

# TUI Framework
ratatui = { version = "0.30", features = ["all-widgets"] }
crossterm = { version = "0.29", features = ["event-stream"] }
ratatui-image = { version = "10.0", default-features = false, features = ["image-defaults", "crossterm"], optional = true }
image = { version = "0.25", optional = true }

# Async Runtime
tokio = { version = "1.41", features = ["full"] }
tokio-util = { version = "0.7", features = ["io"] }
futures = "0.3"

# Serialization/Deserialization
serde = { version = "1.0", features = ["derive", "rc"] }
serde_json = { version = "1.0", features = ["preserve_order", "raw_value"] }

# Error Handling
thiserror = "2.0"
color-eyre = "0.6"
eyre = "0.6"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }

# Time/Date handling
chrono = { version = "0.4", features = ["serde"] }
humantime = "2.1"

# File system utilities
walkdir = "2.5"
dirs = "6.0"
notify = { version = "8.0", features = ["serde"] }
directories = "6.0"
tempfile = "3.14"

# Clipboard
arboard = "3.4"

# Interactive prompts
dialoguer = { version = "0.12", features = ["fuzzy-select"] }

# Search/Filtering
regex = "1.12"
globset = "0.4"
tantivy = "0.25"

# Text Diff
similar = "2.6"

# JSON Schema
jsonschema = "0.41"
schemars = "1.2"

# MCP Server (Model Context Protocol)
mcpkit = { version = "0.5", optional = true }

# Terminal utilities
console = "0.16"
indicatif = { version = "0.18", features = ["tokio"] }
syntect = { version = "5.3", default-features = false, features = ["default-fancy"] }

# Data structures
indexmap = { version = "2.13", features = ["serde"] }
uuid = { version = "1.20", features = ["serde", "v4"] }
semver = { version = "1.0", features = ["serde"] }

# Configuration
toml = "0.9"
config = "0.15"

# Utilities
once_cell = "1.20"
parking_lot = "0.12"
rayon = "1.10"
bytes = "1.11"
base64 = "0.22"
percent-encoding = "2.3"

# Database
rusqlite = { version = "0.38", features = ["bundled"] }

# Memory-mapped files (for zero-copy parsing)
memmap2 = { version = "0.9", optional = true }

[dev-dependencies]
# Testing
pretty_assertions = "1.4"
rust-expect = "0.1"
insta = { version = "1.46", features = ["json", "yaml", "filters"] }
proptest = "1.10"
criterion = { version = "0.8", features = ["async_tokio"] }
tempfile = "3.14"
rstest = "0.26"
tokio-test = "0.4"

[profile.release]
lto = "thin"
opt-level = 3
codegen-units = 1
strip = true

[profile.dev]
opt-level = 1

[profile.dev.package."*"]
opt-level = 3

[[bin]]
name = "snatch"
path = "src/main.rs"

[[bench]]
name = "parser_bench"
harness = false

[features]
default = []
tui = []
tracing = []
mmap = ["dep:memmap2"]  # Memory-mapped file parsing for very large JSONL files
mcp = ["dep:mcpkit"]  # MCP server mode for AI model integration
image-preview = ["dep:ratatui-image", "dep:image"]  # Terminal image preview (sixel/kitty/iterm)

[lints.rust]
# Use deny instead of forbid to allow targeted unsafe in mmap feature
unsafe_code = "deny"

[lints.clippy]
# Set lint groups with lower priority so individual allows take precedence
all = { level = "warn", priority = -1 }
pedantic = { level = "warn", priority = -1 }
nursery = { level = "warn", priority = -1 }

# Allow some pedantic lints that are too strict or purely stylistic
module_name_repetitions = "allow"
must_use_candidate = "allow"
missing_errors_doc = "allow"
missing_panics_doc = "allow"
similar_names = "allow"           # Variable naming style preference
redundant_else = "allow"          # Control flow style preference
needless_raw_string_hashes = "allow"  # Raw string formatting preference
unreadable_literal = "allow"      # Number formatting style preference
unnested_or_patterns = "allow"    # Match pattern style preference
too_many_lines = "allow"          # Function length is not always a problem
cognitive_complexity = "allow"    # Complex functions are sometimes necessary
struct_excessive_bools = "allow"  # Sometimes structs need many bools
struct_field_names = "allow"      # Field naming is contextual
items_after_statements = "allow"  # Helper functions after usage is fine
option_if_let_else = "allow"      # if-let is often clearer than map_or
single_match_else = "allow"       # Explicit match is sometimes clearer
redundant_closure_for_method_calls = "allow"  # Closures can be clearer
use_self = "allow"                # Self vs type name is preference
if_not_else = "allow"             # if !cond is often clearer
match_same_arms = "allow"         # Sometimes explicit arms are clearer
cast_possible_truncation = "allow"  # Truncation is intentional in these cases
cast_sign_loss = "allow"          # Sign loss is intentional
cast_precision_loss = "allow"     # Precision loss is acceptable for display
cast_lossless = "allow"           # Type is clearer than auto-widening
trivially_copy_pass_by_ref = "allow"  # Consistency with other methods
unnecessary_wraps = "allow"       # API consistency sometimes requires wrapping
uninlined_format_args = "allow"   # Format style preference
significant_drop_tightening = "allow"  # Explicit scoping is clearer
return_self_not_must_use = "allow"  # Builder pattern doesn't need must_use
self_named_constructors = "allow" # new() is idiomatic
should_implement_trait = "allow"  # Not all types need full trait impls
missing_const_for_fn = "allow"    # const fn isn't always worth the complexity
needless_pass_by_value = "allow"  # Sometimes owning is clearer
ptr_arg = "allow"                 # &Vec is fine for simple cases
redundant_closure = "allow"       # Closures can be clearer
or_fun_call = "allow"             # unwrap_or vs unwrap_or_else is situational
map_unwrap_or = "allow"           # map().unwrap_or() is often clearer
manual_let_else = "allow"         # if-let vs let-else is preference
match_wildcard_for_single_variants = "allow"  # Explicit variant is clearer
missing_fields_in_debug = "allow" # Debug doesn't need all fields
iter_without_into_iter = "allow"  # Not all types need IntoIterator
needless_borrow = "allow"         # Explicit borrows can be clearer
cast_possible_wrap = "allow"      # Wrap is intentional for diff calculations
doc_markdown = "allow"            # Doc formatting is preference
suboptimal_flops = "allow"        # Readable math is preferred over micro-optimization
format_push_string = "allow"      # format!() is clearer than write!() macros
iter_on_single_items = "allow"    # Sometimes explicit iteration is clearer
unused_self = "allow"             # API consistency sometimes requires self
explicit_iter_loop = "allow"      # for x in iter() is sometimes clearer than for x in &iter
assigning_clones = "allow"        # x = y.clone() is sometimes clearer than x.clone_from(&y)
inefficient_to_string = "allow"   # Readability over micro-optimization
set_contains_or_insert = "allow"  # Explicit check-then-insert can be clearer
io_other_error = "allow"          # io::Error::other is fine for custom errors
redundant_clone = "allow"         # False positives in conditional paths
needless_continue = "allow"       # Explicit continue for clarity in match arms
branches_sharing_code = "allow"   # Sometimes duplicate code is clearer
doc_overindented_list_items = "allow"  # Doc formatting preference
collapsible_match = "allow"       # Sometimes separate matches are clearer
filter_map_next = "allow"         # filter_map().next() can be clearer than find_map
bool_to_int_with_if = "allow"     # Explicit if is clearer for bool to int
field_reassign_with_default = "allow"  # Sometimes sequential assignment is clearer
large_enum_variant = "allow"      # Boxing adds complexity, memory is acceptable
derive_partial_eq_without_eq = "allow"  # Eq not always needed with PartialEq
while_let_loop = "allow"          # Sometimes explicit loop is clearer
elidable_lifetime_names = "allow" # Explicit lifetimes can be clearer
ignored_unit_patterns = "allow"   # _ is clear for unit
unnecessary_join = "allow"        # collect().join() can be clearer
explicit_counter_loop = "allow"   # Manual counter can be clearer
needless_pass_by_ref_mut = "allow"  # &mut ensures API contract
